from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import json
import os
from datetime import datetime

app = FastAPI(title="Kanban Board API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=False,
    allow_methods=["*"],
    allow_headers=["*"],
)

class Task(BaseModel):
    id: int
    text: str
    column: str

class TaskCreate(BaseModel):
    text: str
    column: str = "Planning"

class TaskUpdate(BaseModel):
    text: Optional[str] = None
    column: Optional[str] = None

# In-memory storage for now (will be replaced with Firebase)
tasks_db = []
next_id = 1

# Try to load existing tasks from file
TASKS_FILE = "tasks_backup.json"

def load_tasks():
    global tasks_db, next_id
    try:
        if os.path.exists(TASKS_FILE):
            with open(TASKS_FILE, 'r') as f:
                data = json.load(f)
                tasks_db = data.get('tasks', [])
                next_id = data.get('next_id', 1)
                print(f"Loaded {len(tasks_db)} tasks from backup")
    except Exception as e:
        print(f"Error loading tasks: {e}")
        tasks_db = []
        next_id = 1

def save_tasks():
    try:
        with open(TASKS_FILE, 'w') as f:
            json.dump({
                'tasks': tasks_db,
                'next_id': next_id,
                'last_updated': datetime.now().isoformat()
            }, f, indent=2)
    except Exception as e:
        print(f"Error saving tasks: {e}")

@app.on_event("startup")
async def startup_event():
    """Initialize Firebase and sync data on startup"""
    load_tasks()
    if firebase_connected:
        await sync_with_firebase()

@app.get("/")
async def root():
    return {
        "message": "Kanban Board API is running",
        "tasks_count": len(tasks_db),
        "firebase_status": "connecting..."
    }

@app.get("/tasks", response_model=List[Task])
async def get_tasks():
    try:
        return [Task(**task) for task in tasks_db]
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching tasks: {str(e)}")

@app.post("/tasks", response_model=Task)
async def create_task(task: TaskCreate):
    global next_id
    try:
        new_task = {
            "id": next_id,
            "text": task.text,
            "column": task.column
        }
        
        tasks_db.append(new_task)
        next_id += 1
        
        # Save to Firebase if connected
        if firebase_connected:
            await save_task_to_firebase(new_task)
        
        save_tasks()
        
        print(f"Created task: {new_task}")
        return Task(**new_task)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error creating task: {str(e)}")

@app.put("/tasks/{task_id}", response_model=Task)
async def update_task(task_id: int, task_update: TaskUpdate):
    try:
        # Find the task
        task_index = None
        for i, task in enumerate(tasks_db):
            if task['id'] == task_id:
                task_index = i
                break
        
        if task_index is None:
            raise HTTPException(status_code=404, detail="Task not found")
        
        # Update the task
        update_data = {}
        if task_update.text is not None:
            tasks_db[task_index]['text'] = task_update.text
            update_data['text'] = task_update.text
        if task_update.column is not None:
            tasks_db[task_index]['column'] = task_update.column
            update_data['column'] = task_update.column
        
        # Update in Firebase if connected
        if firebase_connected and update_data:
            await update_task_in_firebase(task_id, update_data)
        
        save_tasks()
        
        print(f"Updated task {task_id}: {tasks_db[task_index]}")
        return Task(**tasks_db[task_index])
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error updating task: {str(e)}")

@app.delete("/tasks/{task_id}")
async def delete_task(task_id: int):
    try:
        # Find and remove the task
        task_index = None
        for i, task in enumerate(tasks_db):
            if task['id'] == task_id:
                task_index = i
                break
        
        if task_index is None:
            raise HTTPException(status_code=404, detail="Task not found")
        
        deleted_task = tasks_db.pop(task_index)
        
        # Delete from Firebase if connected
        if firebase_connected:
            await delete_task_from_firebase(task_id)
        
        save_tasks()
        
        print(f"Deleted task {task_id}: {deleted_task}")
        return {"message": f"Task {task_id} deleted successfully"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error deleting task: {str(e)}")

@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "tasks_count": len(tasks_db),
        "firebase_connected": firebase_connected,
        "storage": "firebase" if firebase_connected else "file_backup"
    }

# Firebase integration
firebase_db = None
firebase_connected = False

def init_firebase():
    global firebase_db, firebase_connected
    try:
        if not os.path.exists("firebase-service-account.json"):
            print("‚ùå Firebase service account file not found")
            return False
            
        # Check if the file contains placeholder values
        with open("firebase-service-account.json", 'r') as f:
            service_account = json.load(f)
            
        if (service_account.get("private_key", "").strip() == "-----BEGIN PRIVATE KEY-----\nyour-private-key\n-----END PRIVATE KEY-----" or
            "your-private-key" in service_account.get("private_key", "") or
            "xxxxx" in service_account.get("client_email", "")):
            print("‚ùå Firebase service account contains placeholder values")
            print("üìù Please replace firebase-service-account.json with real credentials from Firebase Console")
            return False
            
        import firebase_admin
        from firebase_admin import credentials, firestore
        
        # Check if app is already initialized
        try:
            firebase_admin.get_app()
        except ValueError:
            cred = credentials.Certificate("firebase-service-account.json")
            firebase_admin.initialize_app(cred)
        
        firebase_db = firestore.client()
        firebase_connected = True
        
        print("‚úÖ Firebase initialized successfully")
        return True
    except Exception as e:
        print(f"‚ùå Firebase initialization failed: {e}")
        if "InvalidData" in str(e):
            print("üìù The private key in firebase-service-account.json is invalid")
            print("üìù Please download a new service account key from Firebase Console")
        firebase_connected = False
    return False

async def sync_with_firebase():
    """Sync local tasks with Firebase"""
    global tasks_db
    if not firebase_connected or not firebase_db:
        return
    
    try:
        # Get tasks from Firebase
        tasks_ref = firebase_db.collection('kanban-tasks')
        docs = tasks_ref.stream()
        
        firebase_tasks = []
        for doc in docs:
            task_data = doc.to_dict()
            task_data['id'] = int(doc.id)
            firebase_tasks.append(task_data)
        
        if firebase_tasks:
            tasks_db = firebase_tasks
            print(f"Synced {len(firebase_tasks)} tasks from Firebase")
        
    except Exception as e:
        print(f"Firebase sync failed: {e}")

async def save_task_to_firebase(task_data):
    """Save task to Firebase"""
    if not firebase_connected or not firebase_db:
        return False
    
    try:
        doc_ref = firebase_db.collection('kanban-tasks').document(str(task_data['id']))
        doc_ref.set(task_data)
        print(f"Saved task {task_data['id']} to Firebase")
        return True
    except Exception as e:
        print(f"Failed to save task to Firebase: {e}")
        return False

async def update_task_in_firebase(task_id, task_data):
    """Update task in Firebase"""
    if not firebase_connected or not firebase_db:
        return False
    
    try:
        doc_ref = firebase_db.collection('kanban-tasks').document(str(task_id))
        doc_ref.update(task_data)
        print(f"Updated task {task_id} in Firebase")
        return True
    except Exception as e:
        print(f"Failed to update task in Firebase: {e}")
        return False

async def delete_task_from_firebase(task_id):
    """Delete task from Firebase"""
    if not firebase_connected or not firebase_db:
        return False
    
    try:
        doc_ref = firebase_db.collection('kanban-tasks').document(str(task_id))
        doc_ref.delete()
        print(f"Deleted task {task_id} from Firebase")
        return True
    except Exception as e:
        print(f"Failed to delete task from Firebase: {e}")
        return False

# Try to initialize Firebase on startup
init_firebase()

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8001))
    print("üöÄ Starting Kanban Board API...")
    print(f"üìä API Documentation: http://localhost:{port}/docs")
    print("üî• Firebase Status:", "Connected" if firebase_connected else "Using file backup")
    uvicorn.run(app, host="0.0.0.0", port=port)